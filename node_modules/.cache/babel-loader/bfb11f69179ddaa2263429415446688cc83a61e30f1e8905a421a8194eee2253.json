{"ast":null,"code":"const resolveURL = require('resolve-url');\nconst readFromBlobOrFile = blob => new Promise((resolve, reject) => {\n  const fileReader = new FileReader();\n  fileReader.onload = () => {\n    resolve(fileReader.result);\n  };\n  fileReader.onerror = _ref => {\n    let {\n      target: {\n        error: {\n          code\n        }\n      }\n    } = _ref;\n    reject(Error(`File could not be read! Code=${code}`));\n  };\n  fileReader.readAsArrayBuffer(blob);\n});\nmodule.exports = async _data => {\n  let data = _data;\n  if (typeof _data === 'undefined') {\n    return new Uint8Array();\n  }\n  if (typeof _data === 'string') {\n    /* From base64 format */\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n      data = atob(_data.split(',')[1]).split('').map(c => c.charCodeAt(0));\n      /* From remote server/URL */\n    } else {\n      const res = await fetch(resolveURL(_data));\n      data = await res.arrayBuffer();\n    }\n    /* From Blob or File */\n  } else if (_data instanceof File || _data instanceof Blob) {\n    data = await readFromBlobOrFile(_data);\n  }\n  return new Uint8Array(data);\n};","map":{"version":3,"names":["resolveURL","require","readFromBlobOrFile","blob","Promise","resolve","reject","fileReader","FileReader","onload","result","onerror","_ref","target","error","code","Error","readAsArrayBuffer","module","exports","_data","data","Uint8Array","test","atob","split","map","c","charCodeAt","res","fetch","arrayBuffer","File","Blob"],"sources":["/home/dusijian/worksapce/react-app/node_modules/@ffmpeg/ffmpeg/src/browser/fetchFile.js"],"sourcesContent":["const resolveURL = require('resolve-url');\n\nconst readFromBlobOrFile = (blob) => (\n  new Promise((resolve, reject) => {\n    const fileReader = new FileReader();\n    fileReader.onload = () => {\n      resolve(fileReader.result);\n    };\n    fileReader.onerror = ({ target: { error: { code } } }) => {\n      reject(Error(`File could not be read! Code=${code}`));\n    };\n    fileReader.readAsArrayBuffer(blob);\n  })\n);\n\nmodule.exports = async (_data) => {\n  let data = _data;\n  if (typeof _data === 'undefined') {\n    return new Uint8Array();\n  }\n\n  if (typeof _data === 'string') {\n    /* From base64 format */\n    if (/data:_data\\/([a-zA-Z]*);base64,([^\"]*)/.test(_data)) {\n      data = atob(_data.split(',')[1])\n        .split('')\n        .map((c) => c.charCodeAt(0));\n    /* From remote server/URL */\n    } else {\n      const res = await fetch(resolveURL(_data));\n      data = await res.arrayBuffer();\n    }\n  /* From Blob or File */\n  } else if (_data instanceof File || _data instanceof Blob) {\n    data = await readFromBlobOrFile(_data);\n  }\n\n  return new Uint8Array(data);\n};\n"],"mappings":"AAAA,MAAMA,UAAU,GAAGC,OAAO,CAAC,aAAa,CAAC;AAEzC,MAAMC,kBAAkB,GAAIC,IAAI,IAC9B,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;EAC/B,MAAMC,UAAU,GAAG,IAAIC,UAAU,EAAE;EACnCD,UAAU,CAACE,MAAM,GAAG,MAAM;IACxBJ,OAAO,CAACE,UAAU,CAACG,MAAM,CAAC;EAC5B,CAAC;EACDH,UAAU,CAACI,OAAO,GAAGC,IAAA,IAAqC;IAAA,IAApC;MAAEC,MAAM,EAAE;QAAEC,KAAK,EAAE;UAAEC;QAAK;MAAE;IAAE,CAAC,GAAAH,IAAA;IACnDN,MAAM,CAACU,KAAK,CAAE,gCAA+BD,IAAK,EAAC,CAAC,CAAC;EACvD,CAAC;EACDR,UAAU,CAACU,iBAAiB,CAACd,IAAI,CAAC;AACpC,CAAC,CACF;AAEDe,MAAM,CAACC,OAAO,GAAG,MAAOC,KAAK,IAAK;EAChC,IAAIC,IAAI,GAAGD,KAAK;EAChB,IAAI,OAAOA,KAAK,KAAK,WAAW,EAAE;IAChC,OAAO,IAAIE,UAAU,EAAE;EACzB;EAEA,IAAI,OAAOF,KAAK,KAAK,QAAQ,EAAE;IAC7B;IACA,IAAI,wCAAwC,CAACG,IAAI,CAACH,KAAK,CAAC,EAAE;MACxDC,IAAI,GAAGG,IAAI,CAACJ,KAAK,CAACK,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,CAC7BA,KAAK,CAAC,EAAE,CAAC,CACTC,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACC,UAAU,CAAC,CAAC,CAAC,CAAC;MAChC;IACA,CAAC,MAAM;MACL,MAAMC,GAAG,GAAG,MAAMC,KAAK,CAAC9B,UAAU,CAACoB,KAAK,CAAC,CAAC;MAC1CC,IAAI,GAAG,MAAMQ,GAAG,CAACE,WAAW,EAAE;IAChC;IACF;EACA,CAAC,MAAM,IAAIX,KAAK,YAAYY,IAAI,IAAIZ,KAAK,YAAYa,IAAI,EAAE;IACzDZ,IAAI,GAAG,MAAMnB,kBAAkB,CAACkB,KAAK,CAAC;EACxC;EAEA,OAAO,IAAIE,UAAU,CAACD,IAAI,CAAC;AAC7B,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}