{"ast":null,"code":"const {\n  defaultArgs,\n  baseOptions\n} = require('./config');\nconst {\n  setLogging,\n  setCustomLogger,\n  log\n} = require('./utils/log');\nconst parseProgress = require('./utils/parseProgress');\nconst parseArgs = require('./utils/parseArgs');\nconst {\n  defaultOptions,\n  getCreateFFmpegCore\n} = require('./node');\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\nmodule.exports = function () {\n  let _options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n  const detectCompletion = message => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n  const parseMessage = _ref => {\n    let {\n      type,\n      message\n    } = _ref;\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      const createFFmpegCore = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        printErr: message => parseMessage({\n          type: 'fferr',\n          message\n        }),\n        print: message => parseMessage({\n          type: 'ffout',\n          message\n        }),\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined' && typeof window.FFMPEG_CORE_WORKER_SCRIPT !== 'undefined' && path.endsWith('ffmpeg-core.worker.js')) {\n            return window.FFMPEG_CORE_WORKER_SCRIPT;\n          }\n          return prefix + path;\n        }\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = function () {\n    for (var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++) {\n      _args[_key] = arguments[_key];\n    }\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise(resolve => {\n        const args = [...defaultArgs, ..._args].filter(s => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = function (method) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    log('info', `run FS.${method} ${args.map(arg => typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n  const setProgress = _progress => {\n    progress = _progress;\n  };\n  const setLogger = _logger => {\n    setCustomLogger(_logger);\n  };\n  setLogging(logging);\n  setCustomLogger(logger);\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    FS\n  };\n};","map":{"version":3,"names":["defaultArgs","baseOptions","require","setLogging","setCustomLogger","log","parseProgress","parseArgs","defaultOptions","getCreateFFmpegCore","NO_LOAD","Error","module","exports","_options","arguments","length","undefined","logging","logger","progress","optProgress","options","Core","ffmpeg","runResolve","running","detectCompletion","message","parseMessage","_ref","type","load","createFFmpegCore","printErr","print","locateFile","path","prefix","window","FFMPEG_CORE_WORKER_SCRIPT","endsWith","cwrap","isLoaded","run","_len","_args","Array","_key","join","Promise","resolve","args","filter","s","FS","method","_len2","_key2","map","arg","ret","e","setProgress","_progress","setLogger","_logger"],"sources":["/home/dusijian/worksapce/react-app/node_modules/@ffmpeg/ffmpeg/src/createFFmpeg.js"],"sourcesContent":["const { defaultArgs, baseOptions } = require('./config');\nconst { setLogging, setCustomLogger, log } = require('./utils/log');\nconst parseProgress = require('./utils/parseProgress');\nconst parseArgs = require('./utils/parseArgs');\nconst { defaultOptions, getCreateFFmpegCore } = require('./node');\n\nconst NO_LOAD = Error('ffmpeg.wasm is not ready, make sure you have completed load().');\n\nmodule.exports = (_options = {}) => {\n  const {\n    log: logging,\n    logger,\n    progress: optProgress,\n    ...options\n  } = {\n    ...baseOptions,\n    ...defaultOptions,\n    ..._options,\n  };\n  let Core = null;\n  let ffmpeg = null;\n  let runResolve = null;\n  let running = false;\n  let progress = optProgress;\n  const detectCompletion = (message) => {\n    if (message === 'FFMPEG_END' && runResolve !== null) {\n      runResolve();\n      runResolve = null;\n      running = false;\n    }\n  };\n  const parseMessage = ({ type, message }) => {\n    log(type, message);\n    parseProgress(message, progress);\n    detectCompletion(message);\n  };\n\n  /*\n   * Load ffmpeg.wasm-core script.\n   * In browser environment, the ffmpeg.wasm-core script is fetch from\n   * CDN and can be assign to a local path by assigning `corePath`.\n   * In node environment, we use dynamic require and the default `corePath`\n   * is `$ffmpeg/core`.\n   *\n   * Typically the load() func might take few seconds to minutes to complete,\n   * better to do it as early as possible.\n   *\n   */\n  const load = async () => {\n    log('info', 'load ffmpeg-core');\n    if (Core === null) {\n      log('info', 'loading ffmpeg-core');\n      const createFFmpegCore = await getCreateFFmpegCore(options);\n      Core = await createFFmpegCore({\n        printErr: (message) => parseMessage({ type: 'fferr', message }),\n        print: (message) => parseMessage({ type: 'ffout', message }),\n        locateFile: (path, prefix) => {\n          if (typeof window !== 'undefined'\n            && typeof window.FFMPEG_CORE_WORKER_SCRIPT !== 'undefined'\n            && path.endsWith('ffmpeg-core.worker.js')) {\n            return window.FFMPEG_CORE_WORKER_SCRIPT;\n          }\n          return prefix + path;\n        },\n      });\n      ffmpeg = Core.cwrap('proxy_main', 'number', ['number', 'number']);\n      log('info', 'ffmpeg-core loaded');\n    } else {\n      throw Error('ffmpeg.wasm was loaded, you should not load it again, use ffmpeg.isLoaded() to check next time.');\n    }\n  };\n\n\n  /*\n   * Determine whether the Core is loaded.\n   */\n  const isLoaded = () => Core !== null;\n\n  /*\n   * Run ffmpeg command.\n   * This is the major function in ffmpeg.wasm, you can just imagine it\n   * as ffmpeg native cli and what you need to pass is the same.\n   *\n   * For example, you can convert native command below:\n   *\n   * ```\n   * $ ffmpeg -i video.avi -c:v libx264 video.mp4\n   * ```\n   *\n   * To\n   *\n   * ```\n   * await ffmpeg.run('-i', 'video.avi', '-c:v', 'libx264', 'video.mp4');\n   * ```\n   *\n   */\n  const run = (..._args) => {\n    log('info', `run ffmpeg command: ${_args.join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else if (running) {\n      throw Error('ffmpeg.wasm can only run one command at a time');\n    } else {\n      running = true;\n      return new Promise((resolve) => {\n        const args = [...defaultArgs, ..._args].filter((s) => s.length !== 0);\n        runResolve = resolve;\n        ffmpeg(...parseArgs(Core, args));\n      });\n    }\n  };\n\n  /*\n   * Run FS operations.\n   * For input/output file of ffmpeg.wasm, it is required to save them to MEMFS\n   * first so that ffmpeg.wasm is able to consume them. Here we rely on the FS\n   * methods provided by Emscripten.\n   *\n   * Common methods to use are:\n   * ffmpeg.FS('writeFile', 'video.avi', new Uint8Array(...)): writeFile writes\n   * data to MEMFS. You need to use Uint8Array for binary data.\n   * ffmpeg.FS('readFile', 'video.mp4'): readFile from MEMFS.\n   * ffmpeg.FS('unlink', 'video.map'): delete file from MEMFS.\n   *\n   * For more info, check https://emscripten.org/docs/api_reference/Filesystem-API.html\n   *\n   */\n  const FS = (method, ...args) => {\n    log('info', `run FS.${method} ${args.map((arg) => (typeof arg === 'string' ? arg : `<${arg.length} bytes binary file>`)).join(' ')}`);\n    if (Core === null) {\n      throw NO_LOAD;\n    } else {\n      let ret = null;\n      try {\n        ret = Core.FS[method](...args);\n      } catch (e) {\n        if (method === 'readdir') {\n          throw Error(`ffmpeg.FS('readdir', '${args[0]}') error. Check if the path exists, ex: ffmpeg.FS('readdir', '/')`);\n        } else if (method === 'readFile') {\n          throw Error(`ffmpeg.FS('readFile', '${args[0]}') error. Check if the path exists`);\n        } else {\n          throw Error('Oops, something went wrong in FS operation.');\n        }\n      }\n      return ret;\n    }\n  };\n\n  const setProgress = (_progress) => {\n    progress = _progress;\n  };\n\n  const setLogger = (_logger) => {\n    setCustomLogger(_logger);\n  };\n\n  setLogging(logging);\n  setCustomLogger(logger);\n\n  return {\n    setProgress,\n    setLogger,\n    setLogging,\n    load,\n    isLoaded,\n    run,\n    FS,\n  };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}